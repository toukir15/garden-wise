{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/OneDrive/Desktop/Next-Level-Technology/Assingment/Assingment6/client/node_modules/@tanstack/query-core/src/utils.ts"],"sourcesContent":["import type { Mutation } from './mutation'\nimport type { Query } from './query'\nimport type {\n  FetchStatus,\n  MutationFunction,\n  MutationKey,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (mutation: Mutation<any, any, any>) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Include or exclude fetching mutations\n   */\n  fetching?: boolean\n}\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in window\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function difference<T>(array1: T[], array2: T[]): T[] {\n  return array1.filter((x) => !array2.includes(x))\n}\n\nexport function replaceAt<T>(array: T[], index: number, value: T): T[] {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function parseQueryArgs<\n  TOptions extends QueryOptions<any, any, any, TQueryKey>,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | TOptions,\n  arg2?: QueryFunction<any, TQueryKey> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (!isQueryKey(arg1)) {\n    return arg1 as TOptions\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3, queryKey: arg1, queryFn: arg2 } as TOptions\n  }\n\n  return { ...arg2, queryKey: arg1 } as TOptions\n}\n\nexport function parseMutationArgs<\n  TOptions extends MutationOptions<any, any, any, any>,\n>(\n  arg1: MutationKey | MutationFunction<any, any> | TOptions,\n  arg2?: MutationFunction<any, any> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3, mutationKey: arg1, mutationFn: arg2 } as TOptions\n    }\n    return { ...arg2, mutationKey: arg1 } as TOptions\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2, mutationFn: arg1 } as TOptions\n  }\n\n  return { ...arg1 } as TOptions\n}\n\nexport function parseFilterArgs<\n  TFilters extends QueryFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1) ? [{ ...arg2, queryKey: arg1 }, arg3] : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function parseMutationFilterArgs<\n  TFilters extends MutationFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1)\n      ? [{ ...arg2, mutationKey: arg1 }, arg3]\n      : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (\n    typeof fetchStatus !== 'undefined' &&\n    fetchStatus !== query.state.fetchStatus\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, fetching, predicate, mutationKey } = filters\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (\n        hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)\n      ) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (\n    typeof fetching === 'boolean' &&\n    (mutation.state.status === 'loading') !== fetching\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: QueryOptions<any, any, any, TQueryKey>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashQueryKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashQueryKey(queryKey: QueryKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean {\n  return partialDeepEqual(a, b)\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\nexport function shallowEqualObjects<T>(a: T, b: T): boolean {\n  if ((a && !b) || (b && !a)) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isQueryKey(value: unknown): value is QueryKey {\n  return Array.isArray(value)\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout)\n  })\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nexport function scheduleMicrotask(callback: () => void) {\n  sleep(0).then(callback)\n}\n\nexport function getAbortController(): AbortController | undefined {\n  if (typeof AbortController === 'function') {\n    return new AbortController()\n  }\n  return\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual?.(prevData, data)) {\n    return prevData as TData\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data)\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n"],"names":["isServer","window","noop","undefined","functionalUpdate","updater","input","isValidTimeout","value","Infinity","difference","array1","array2","filter","x","includes","replaceAt","array","index","copy","slice","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","parseQueryArgs","arg1","arg2","arg3","isQueryKey","queryKey","queryFn","parseMutationArgs","mutationKey","mutationFn","parseFilterArgs","parseMutationFilterArgs","matchQuery","filters","query","type","exact","fetchStatus","predicate","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","state","matchMutation","mutation","fetching","hashQueryKey","status","hashFn","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","Object","keys","sort","reduce","result","key","a","b","partialDeepEqual","some","replaceEqualDeep","isPlainArray","aSize","length","bItems","bSize","equalItems","i","shallowEqualObjects","Array","isArray","o","hasObjectPrototype","ctor","constructor","prot","prototype","hasOwnProperty","toString","call","isError","Error","sleep","timeout","Promise","resolve","setTimeout","scheduleMicrotask","callback","then","getAbortController","AbortController","replaceData","prevData","data","isDataEqual","structuralSharing"],"mappings":"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"}},
    {"offset": {"line": 305, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 310, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/OneDrive/Desktop/Next-Level-Technology/Assingment/Assingment6/client/node_modules/@tanstack/query-core/src/logger.ts"],"sourcesContent":["export interface Logger {\n  log: LogFunction\n  warn: LogFunction\n  error: LogFunction\n}\n\ntype LogFunction = (...args: any[]) => void\n\nexport const defaultLogger: Logger = console\n"],"names":["defaultLogger","console"],"mappings":";;;AAQO,MAAMA,gBAAwBC"}},
    {"offset": {"line": 316, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 321, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/OneDrive/Desktop/Next-Level-Technology/Assingment/Assingment6/client/node_modules/@tanstack/query-core/src/notifyManager.ts"],"sourcesContent":["import { scheduleMicrotask } from './utils'\n\n// TYPES\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\ntype BatchCallsCallback<T extends unknown[]> = (...args: T) => void\n\nexport function createNotifyManager() {\n  let queue: NotifyCallback[] = []\n  let transactions = 0\n  let notifyFn: NotifyFunction = (callback) => {\n    callback()\n  }\n  let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {\n    callback()\n  }\n\n  const batch = <T>(callback: () => T): T => {\n    let result\n    transactions++\n    try {\n      result = callback()\n    } finally {\n      transactions--\n      if (!transactions) {\n        flush()\n      }\n    }\n    return result\n  }\n\n  const schedule = (callback: NotifyCallback): void => {\n    if (transactions) {\n      queue.push(callback)\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback)\n      })\n    }\n  }\n\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n  const batchCalls = <T extends unknown[]>(\n    callback: BatchCallsCallback<T>,\n  ): BatchCallsCallback<T> => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args)\n      })\n    }\n  }\n\n  const flush = (): void => {\n    const originalQueue = queue\n    queue = []\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n  const setNotifyFunction = (fn: NotifyFunction) => {\n    notifyFn = fn\n  }\n\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n  const setBatchNotifyFunction = (fn: BatchNotifyFunction) => {\n    batchNotifyFn = fn\n  }\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction,\n  } as const\n}\n\n// SINGLETON\nexport const notifyManager = createNotifyManager()\n"],"names":["createNotifyManager","queue","transactions","notifyFn","callback","batchNotifyFn","batch","result","flush","schedule","push","scheduleMicrotask","batchCalls","args","originalQueue","length","forEach","setNotifyFunction","fn","setBatchNotifyFunction","notifyManager"],"mappings":";;;;;;;AAYO,SAASA;IACd,IAAIC,QAA0B,EAA9B;IACA,IAAIC,eAAe;IACnB,IAAIC,WAA4BC,CAAAA;QAC9BA;;IAEF,IAAIC,gBAAsCD,CAAAA;QACxCA;;IAGF,MAAME,QAAYF,CAAAA;QAChB,IAAIG;QACJL;QACA,IAAI;YACFK,SAASH;QACV,SAAS;YACRF;YACA,IAAI,CAACA,cAAc;gBACjBM;YACD;QACF;QACD,OAAOD;;IAGT,MAAME,WAAYL,CAAAA;QAChB,IAAIF,cAAc;YAChBD,MAAMS,IAAN,CAAWN;QACZ,OAAM;YACLO,CAAAA,GAAAA,kQAAAA,CAAAA,oBAAiB,AAAjBA,EAAkB;gBAChBR,SAASC;YACV;QACF;;IAGH;;GAEF,GACE,MAAMQ,aACJR,CAAAA;QAEA,OAAO,CAAC,GAAGS;YACTJ,SAAS;gBACPL,YAAYS;YACb;;;IAIL,MAAML,QAAQ;QACZ,MAAMM,gBAAgBb;QACtBA,QAAQ,EAAR;QACA,IAAIa,cAAcC,MAAlB,EAA0B;YACxBJ,CAAAA,GAAAA,kQAAAA,CAAAA,oBAAiB,AAAjBA,EAAkB;gBAChBN,cAAc;oBACZS,cAAcE,OAAd,CAAuBZ,CAAAA;wBACrBD,SAASC;;gBAEZ;YACF;QACF;;IAGH;;;GAGF,GACE,MAAMa,oBAAqBC,CAAAA;QACzBf,WAAWe;;IAGb;;;GAGF,GACE,MAAMC,yBAA0BD,CAAAA;QAC9Bb,gBAAgBa;;IAGlB,OAAO;QACLZ;QACAM;QACAH;QACAQ;QACAE;;AAEH,EAAA,YAAA;AAGYC,MAAAA,gBAAgBpB"}},
    {"offset": {"line": 404, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 409, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/OneDrive/Desktop/Next-Level-Technology/Assingment/Assingment6/client/node_modules/@tanstack/query-core/src/subscribable.ts"],"sourcesContent":["type Listener = () => void\n\nexport class Subscribable<TListener extends Function = Listener> {\n  protected listeners: Set<{ listener: TListener }>\n\n  constructor() {\n    this.listeners = new Set()\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  subscribe(listener: TListener): () => void {\n    const identity = { listener }\n    this.listeners.add(identity)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners.delete(identity)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.size > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n"],"names":["Subscribable","constructor","listeners","Set","subscribe","bind","listener","identity","add","onSubscribe","delete","onUnsubscribe","hasListeners","size"],"mappings":";;;AAEO,MAAMA;IAGXC,aAAc;QACZ,IAAA,CAAKC,SAAL,GAAiB,IAAIC;QACrB,IAAKC,CAAAA,SAAL,GAAiB,IAAKA,CAAAA,SAAL,CAAeC,IAAf,CAAoB,IAApB;IAClB;IAEDD,UAAUE,QAAD,EAAkC;QACzC,MAAMC,WAAW;YAAED;;QACnB,IAAA,CAAKJ,SAAL,CAAeM,GAAf,CAAmBD;QAEnB,IAAA,CAAKE,WAAL;QAEA,OAAO;YACL,IAAA,CAAKP,SAAL,CAAeQ,MAAf,CAAsBH;YACtB,IAAA,CAAKI,aAAL;;IAEH;IAEDC,eAAwB;QACtB,OAAO,IAAKV,CAAAA,SAAL,CAAeW,IAAf,GAAsB;IAC9B;IAESJ,cAAoB,CAE7B;IAESE,gBAAsB,CAE/B;AA9B8D"}},
    {"offset": {"line": 436, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 441, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/OneDrive/Desktop/Next-Level-Technology/Assingment/Assingment6/client/node_modules/@tanstack/query-core/src/focusManager.ts"],"sourcesContent":["import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setFocused: (focused?: boolean) => void,\n) => (() => void) | undefined\n\nexport class FocusManager extends Subscribable {\n  private focused?: boolean\n  private cleanup?: () => void\n\n  private setup: SetupFn\n\n  constructor() {\n    super()\n    this.setup = (onFocus) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus()\n        // Listen to visibillitychange and focus\n        window.addEventListener('visibilitychange', listener, false)\n        window.addEventListener('focus', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener)\n          window.removeEventListener('focus', listener)\n        }\n      }\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.cleanup?.()\n      this.cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.setup = setup\n    this.cleanup?.()\n    this.cleanup = setup((focused) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    const changed = this.focused !== focused\n    if (changed) {\n      this.focused = focused\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    this.listeners.forEach(({ listener }) => {\n      listener()\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.focused === 'boolean') {\n      return this.focused\n    }\n\n    // document global can be unavailable in react native\n    if (typeof document === 'undefined') {\n      return true\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(\n      document.visibilityState,\n    )\n  }\n}\n\nexport const focusManager = new FocusManager()\n"],"names":["FocusManager","Subscribable","constructor","setup","onFocus","isServer","window","addEventListener","listener","removeEventListener","onSubscribe","cleanup","setEventListener","onUnsubscribe","hasListeners","undefined","focused","setFocused","changed","listeners","forEach","isFocused","document","includes","visibilityState","focusManager"],"mappings":";;;;;;;;;AAOO,MAAMA,qBAAqBC,yQAAAA,CAAAA,eAA3B;IAMLC,aAAc;QACZ,KAAA;QACA,IAAKC,CAAAA,KAAL,GAAcC,CAAAA;YACZ,mEAAA;YACA,uEAAA;YACA,IAAI,CAACC,kQAAAA,CAAAA,WAAD,IAAaC,OAAOC,gBAAxB,EAA0C;gBACxC,MAAMC,WAAW,IAAMJ,WADiB,wCAAA;gBAGxCE,OAAOC,gBAAP,CAAwB,oBAAoBC,UAAU;gBACtDF,OAAOC,gBAAP,CAAwB,SAASC,UAAU;gBAE3C,OAAO;oBACL,iDAAA;oBACAF,OAAOG,mBAAP,CAA2B,oBAAoBD;oBAC/CF,OAAOG,mBAAP,CAA2B,SAASD;;YAEvC;YACD;;IAEH;IAESE,cAAoB;QAC5B,IAAI,CAAC,IAAKC,CAAAA,OAAV,EAAmB;YACjB,IAAKC,CAAAA,gBAAL,CAAsB,IAAA,CAAKT,KAA3B;QACD;IACF;IAESU,gBAAgB;QACxB,IAAI,CAAC,IAAA,CAAKC,YAAL,IAAqB;YAAA,IAAA;YACxB,CAAA,gBAAA,IAAA,CAAKH,OAAL,KAAA,OAAA,KAAA,IAAA,cAAA,IAAA,CAAA,IAAA;YACA,IAAKA,CAAAA,OAAL,GAAeI;QAChB;IACF;IAEDH,iBAAiBT,KAAD,EAAuB;QAAA,IAAA;QACrC,IAAKA,CAAAA,KAAL,GAAaA;QACb,CAAA,iBAAA,IAAA,CAAKQ,OAAL,KAAA,OAAA,KAAA,IAAA,eAAA,IAAA,CAAA,IAAA;QACA,IAAA,CAAKA,OAAL,GAAeR,MAAOa,CAAAA;YACpB,IAAI,OAAOA,YAAY,WAAW;gBAChC,IAAKC,CAAAA,UAAL,CAAgBD;YACjB,OAAM;gBACL,IAAA,CAAKZ,OAAL;YACD;QACF;IACF;IAEDa,WAAWD,OAAD,EAA0B;QAClC,MAAME,UAAU,IAAKF,CAAAA,OAAL,KAAiBA;QACjC,IAAIE,SAAS;YACX,IAAKF,CAAAA,OAAL,GAAeA;YACf,IAAA,CAAKZ,OAAL;QACD;IACF;IAEDA,UAAgB;QACd,IAAA,CAAKe,SAAL,CAAeC,OAAf,CAAuB,CAAC,EAAEZ,QAAAA,EAAH;YACrBA;;IAEH;IAEDa,YAAqB;QACnB,IAAI,OAAO,IAAA,CAAKL,OAAZ,KAAwB,WAAW;YACrC,OAAO,IAAA,CAAKA,OAAZ;QACD,EAHkB,qDAAA;QAMnB,IAAI,OAAOM,aAAa,aAAa;YACnC,OAAO;QACR;QAED,OAAO;YAACP;YAAW;YAAW;SAAaQ,CAAAA,QAApC,CACLD,SAASE,eADJ;IAGR;AA/E4C;AAkFlCC,MAAAA,eAAe,IAAIzB"}},
    {"offset": {"line": 522, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 527, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/OneDrive/Desktop/Next-Level-Technology/Assingment/Assingment6/client/node_modules/@tanstack/query-core/src/onlineManager.ts"],"sourcesContent":["import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setOnline: (online?: boolean) => void,\n) => (() => void) | undefined\n\nconst onlineEvents = ['online', 'offline'] as const\n\nexport class OnlineManager extends Subscribable {\n  private online?: boolean\n  private cleanup?: () => void\n\n  private setup: SetupFn\n\n  constructor() {\n    super()\n    this.setup = (onOnline) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline()\n        // Listen to online\n        onlineEvents.forEach((event) => {\n          window.addEventListener(event, listener, false)\n        })\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          onlineEvents.forEach((event) => {\n            window.removeEventListener(event, listener)\n          })\n        }\n      }\n\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.cleanup?.()\n      this.cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.setup = setup\n    this.cleanup?.()\n    this.cleanup = setup((online?: boolean) => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online)\n      } else {\n        this.onOnline()\n      }\n    })\n  }\n\n  setOnline(online?: boolean): void {\n    const changed = this.online !== online\n\n    if (changed) {\n      this.online = online\n      this.onOnline()\n    }\n  }\n\n  onOnline(): void {\n    this.listeners.forEach(({ listener }) => {\n      listener()\n    })\n  }\n\n  isOnline(): boolean {\n    if (typeof this.online === 'boolean') {\n      return this.online\n    }\n\n    if (\n      typeof navigator === 'undefined' ||\n      typeof navigator.onLine === 'undefined'\n    ) {\n      return true\n    }\n\n    return navigator.onLine\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n"],"names":["onlineEvents","OnlineManager","Subscribable","constructor","setup","onOnline","isServer","window","addEventListener","listener","forEach","event","removeEventListener","onSubscribe","cleanup","setEventListener","onUnsubscribe","hasListeners","undefined","online","setOnline","changed","listeners","isOnline","navigator","onLine","onlineManager"],"mappings":";;;;;;;;;AAOA,MAAMA,eAAe;IAAC;IAAU;CAAhC;AAEO,MAAMC,sBAAsBC,yQAAAA,CAAAA,eAA5B;IAMLC,aAAc;QACZ,KAAA;QACA,IAAKC,CAAAA,KAAL,GAAcC,CAAAA;YACZ,mEAAA;YACA,uEAAA;YACA,IAAI,CAACC,kQAAAA,CAAAA,WAAD,IAAaC,OAAOC,gBAAxB,EAA0C;gBACxC,MAAMC,WAAW,IAAMJ,YADiB,mBAAA;gBAGxCL,aAAaU,OAAb,CAAsBC,CAAAA;oBACpBJ,OAAOC,gBAAP,CAAwBG,OAAOF,UAAU;;gBAG3C,OAAO;oBACL,iDAAA;oBACAT,aAAaU,OAAb,CAAsBC,CAAAA;wBACpBJ,OAAOK,mBAAP,CAA2BD,OAAOF;;;YAGvC;YAED;;IAEH;IAESI,cAAoB;QAC5B,IAAI,CAAC,IAAKC,CAAAA,OAAV,EAAmB;YACjB,IAAKC,CAAAA,gBAAL,CAAsB,IAAA,CAAKX,KAA3B;QACD;IACF;IAESY,gBAAgB;QACxB,IAAI,CAAC,IAAA,CAAKC,YAAL,IAAqB;YAAA,IAAA;YACxB,CAAA,gBAAA,IAAA,CAAKH,OAAL,KAAA,OAAA,KAAA,IAAA,cAAA,IAAA,CAAA,IAAA;YACA,IAAKA,CAAAA,OAAL,GAAeI;QAChB;IACF;IAEDH,iBAAiBX,KAAD,EAAuB;QAAA,IAAA;QACrC,IAAKA,CAAAA,KAAL,GAAaA;QACb,CAAA,iBAAA,IAAA,CAAKU,OAAL,KAAA,OAAA,KAAA,IAAA,eAAA,IAAA,CAAA,IAAA;QACA,IAAA,CAAKA,OAAL,GAAeV,MAAOe,CAAAA;YACpB,IAAI,OAAOA,WAAW,WAAW;gBAC/B,IAAKC,CAAAA,SAAL,CAAeD;YAChB,OAAM;gBACL,IAAA,CAAKd,QAAL;YACD;QACF;IACF;IAEDe,UAAUD,MAAD,EAAyB;QAChC,MAAME,UAAU,IAAKF,CAAAA,MAAL,KAAgBA;QAEhC,IAAIE,SAAS;YACX,IAAKF,CAAAA,MAAL,GAAcA;YACd,IAAA,CAAKd,QAAL;QACD;IACF;IAEDA,WAAiB;QACf,IAAA,CAAKiB,SAAL,CAAeZ,OAAf,CAAuB,CAAC,EAAED,QAAAA,EAAH;YACrBA;;IAEH;IAEDc,WAAoB;QAClB,IAAI,OAAO,IAAA,CAAKJ,MAAZ,KAAuB,WAAW;YACpC,OAAO,IAAA,CAAKA,MAAZ;QACD;QAED,IACE,OAAOK,cAAc,eACrB,OAAOA,UAAUC,MAAjB,KAA4B,aAC5B;YACA,OAAO;QACR;QAED,OAAOD,UAAUC,MAAjB;IACD;AAnF6C;AAsFnCC,MAAAA,gBAAgB,IAAIzB"}},
    {"offset": {"line": 610, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 615, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/OneDrive/Desktop/Next-Level-Technology/Assingment/Assingment6/client/node_modules/@tanstack/query-core/src/retryer.ts"],"sourcesContent":["import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { sleep } from './utils'\nimport type { CancelOptions, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = unknown> {\n  fn: () => TData | Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = unknown> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = unknown>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => boolean) | undefined\n  let promiseResolve: (data: TData) => void\n  let promiseReject: (error: TError) => void\n\n  const promise = new Promise<TData>((outerResolve, outerReject) => {\n    promiseResolve = outerResolve\n    promiseReject = outerReject\n  })\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const shouldPause = () =>\n    !focusManager.isFocused() ||\n    (config.networkMode !== 'always' && !onlineManager.isOnline())\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      promiseResolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      promiseReject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        const canContinue = isResolved || !shouldPause()\n        if (canContinue) {\n          continueResolve(value)\n        }\n        return canContinue\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // Execute query\n    try {\n      promiseOrValue = config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? 3\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            if (shouldPause()) {\n              return pause()\n            }\n            return\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  // Start loop\n  if (canFetch(config.networkMode)) {\n    run()\n  } else {\n    pause().then(run)\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn?.()\n      return didContinue ? promise : Promise.resolve()\n    },\n    cancelRetry,\n    continueRetry,\n  }\n}\n"],"names":["defaultRetryDelay","failureCount","Math","min","canFetch","networkMode","onlineManager","isOnline","CancelledError","constructor","options","revert","silent","isCancelledError","value","createRetryer","config","isRetryCancelled","isResolved","continueFn","promiseResolve","promiseReject","promise","Promise","outerResolve","outerReject","cancel","cancelOptions","reject","abort","cancelRetry","continueRetry","shouldPause","focusManager","isFocused","resolve","onSuccess","onError","pause","continueResolve","canContinue","onPause","then","undefined","onContinue","run","promiseOrValue","fn","error","catch","retry","retryDelay","delay","shouldRetry","onFail","sleep","continue","didContinue"],"mappings":"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"}},
    {"offset": {"line": 761, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 766, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/OneDrive/Desktop/Next-Level-Technology/Assingment/Assingment6/client/node_modules/@tanstack/query-core/src/removable.ts"],"sourcesContent":["import { isServer, isValidTimeout } from './utils'\n\nexport abstract class Removable {\n  cacheTime!: number\n  private gcTimeout?: ReturnType<typeof setTimeout>\n\n  destroy(): void {\n    this.clearGcTimeout()\n  }\n\n  protected scheduleGc(): void {\n    this.clearGcTimeout()\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove()\n      }, this.cacheTime)\n    }\n  }\n\n  protected updateCacheTime(newCacheTime: number | undefined): void {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(\n      this.cacheTime || 0,\n      newCacheTime ?? (isServer ? Infinity : 5 * 60 * 1000),\n    )\n  }\n\n  protected clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout)\n      this.gcTimeout = undefined\n    }\n  }\n\n  protected abstract optionalRemove(): void\n}\n"],"names":["Removable","destroy","clearGcTimeout","scheduleGc","isValidTimeout","cacheTime","gcTimeout","setTimeout","optionalRemove","updateCacheTime","newCacheTime","Math","max","isServer","Infinity","clearTimeout","undefined"],"mappings":";;;;;;AAEO,MAAeA;IAIpBC,UAAgB;QACd,IAAA,CAAKC,cAAL;IACD;IAESC,aAAmB;QAC3B,IAAA,CAAKD,cAAL;QAEA,IAAIE,CAAAA,GAAAA,kQAAAA,CAAAA,iBAAc,AAAdA,EAAe,IAAKC,CAAAA,SAAN,GAAkB;YAClC,IAAA,CAAKC,SAAL,GAAiBC,WAAW;gBAC1B,IAAA,CAAKC,cAAL;eACC,IAAKH,CAAAA,SAFmB;QAG5B;IACF;IAESI,gBAAgBC,YAAD,EAAyC;QAChE,0EAAA;QACA,IAAKL,CAAAA,SAAL,GAAiBM,KAAKC,GAAL,CACf,IAAA,CAAKP,SAAL,IAAkB,GAClBK,gBAAAA,OAAAA,eAAiBG,kQAAAA,CAAAA,WAAQ,GAAGC,WAAW,IAAI,KAAK;IAEnD;IAESZ,iBAAiB;QACzB,IAAI,IAAA,CAAKI,SAAT,EAAoB;YAClBS,aAAa,IAAKT,CAAAA,SAAN;YACZ,IAAKA,CAAAA,SAAL,GAAiBU;QAClB;IACF;AA/B6B"}},
    {"offset": {"line": 797, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 802, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/OneDrive/Desktop/Next-Level-Technology/Assingment/Assingment6/client/node_modules/@tanstack/query-core/src/query.ts"],"sourcesContent":["import { getAbortController, noop, replaceData, timeUntilStale } from './utils'\nimport { defaultLogger } from './logger'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type {\n  CancelOptions,\n  FetchStatus,\n  InitialDataFunction,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport type { QueryObserver } from './queryObserver'\nimport type { Logger } from './logger'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  cache: QueryCache\n  queryKey: TQueryKey\n  queryHash: string\n  logger?: Logger\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = unknown> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: any\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal?: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n  ) => void\n}\n\nexport interface FetchOptions {\n  cancelRefetch?: boolean\n  meta?: any\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: any\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  initialState: QueryState<TData, TError>\n  revertState?: QueryState<TData, TError>\n  state: QueryState<TData, TError>\n  isFetchingOptimistic?: boolean\n\n  private cache: QueryCache\n  private logger: Logger\n  private promise?: Promise<TData>\n  private retryer?: Retryer<TData>\n  private observers: QueryObserver<any, any, any, any, any>[]\n  private defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  private abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.abortSignalConsumed = false\n    this.defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.cache = config.cache\n    this.logger = config.logger || defaultLogger\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.initialState = config.state || getDefaultState(this.options)\n    this.state = this.initialState\n    this.scheduleGc()\n  }\n\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  private setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.defaultOptions, ...options }\n\n    this.updateCacheTime(this.options.cacheTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.promise\n    this.retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some((observer) => observer.options.enabled !== false)\n  }\n\n  isDisabled(): boolean {\n    return this.getObserversCount() > 0 && !this.isActive()\n  }\n\n  isStale(): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      this.observers.some((observer) => observer.getCurrentResult().isStale)\n    )\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    if (observer) {\n      observer.refetch({ cancelRefetch: false })\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    if (observer) {\n      observer.refetch({ cancelRefetch: false })\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({ revert: true })\n          } else {\n            this.retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({ silent: true })\n      } else if (this.promise) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.retryer?.continueRetry()\n        // Return current promise if we are already fetching\n        return this.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        this.logger.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = getAbortController()\n\n    // Create query function context\n    const queryFnContext: QueryFunctionContext<TQueryKey> = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta,\n    }\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true\n            return abortController.signal\n          }\n          return undefined\n        },\n      })\n    }\n\n    addSignalProperty(queryFnContext)\n\n    // Create fetch function\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject(\n          `Missing queryFn for queryKey '${this.options.queryHash}'`,\n        )\n      }\n      this.abortSignalConsumed = false\n      return this.options.queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const context: FetchContext<TQueryFnData, TError, TData, TQueryKey> = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n    }\n\n    addSignalProperty(context)\n\n    this.options.behavior?.onFetch(context)\n\n    // Store state in case the current fetch needs to be reverted\n    this.revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.cache.config.onError?.(error, this as Query<any, any, any, any>)\n        this.cache.config.onSettled?.(\n          this.state.data,\n          error,\n          this as Query<any, any, any, any>,\n        )\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error)\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      }\n      this.isFetchingOptimistic = false\n    }\n\n    // Try to fetch the data\n    this.retryer = createRetryer({\n      fn: context.fetchFn as () => TData,\n      abort: abortController?.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (typeof data === 'undefined') {\n          if (process.env.NODE_ENV !== 'production') {\n            this.logger.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        this.setData(data as TData)\n\n        // Notify cache callback\n        this.cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.cache.config.onSettled?.(\n          data,\n          this.state.error,\n          this as Query<any, any, any, any>,\n        )\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc()\n        }\n        this.isFetchingOptimistic = false\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n    })\n\n    this.promise = this.retryer.promise\n\n    return this.promise\n  }\n\n  private dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: action.meta ?? null,\n            fetchStatus: canFetch(this.options.networkMode)\n              ? 'fetching'\n              : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading',\n            }),\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error as unknown\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error: error as TError,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error as TError,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate(action)\n      })\n\n      this.cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = typeof data !== 'undefined'\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle',\n  }\n}\n"],"names":["Query","Removable","constructor","config","abortSignalConsumed","defaultOptions","setOptions","options","observers","cache","logger","defaultLogger","queryKey","queryHash","initialState","state","getDefaultState","scheduleGc","meta","updateCacheTime","cacheTime","optionalRemove","length","fetchStatus","remove","setData","newData","data","replaceData","dispatch","type","dataUpdatedAt","updatedAt","manual","setState","setStateOptions","cancel","promise","retryer","then","noop","catch","Promise","resolve","destroy","silent","reset","isActive","some","observer","enabled","isDisabled","getObserversCount","isStale","isInvalidated","getCurrentResult","isStaleByTime","staleTime","timeUntilStale","onFocus","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","continue","onOnline","shouldFetchOnReconnect","addObserver","includes","push","clearGcTimeout","notify","query","removeObserver","filter","revert","cancelRetry","invalidate","fetch","fetchOptions","continueRetry","queryFn","Array","isArray","error","abortController","getAbortController","queryFnContext","pageParam","undefined","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","fetchFn","reject","context","behavior","onFetch","revertState","fetchMeta","onError","isCancelledError","onSettled","isFetchingOptimistic","createRetryer","fn","abort","bind","onSuccess","Error","onFail","failureCount","onPause","onContinue","retry","retryDelay","networkMode","action","reducer","fetchFailureCount","fetchFailureReason","canFetch","status","dataUpdateCount","Date","now","errorUpdateCount","errorUpdatedAt","notifyManager","batch","forEach","onQueryUpdate","initialData","hasData","initialDataUpdatedAt"],"mappings":"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"}},
    {"offset": {"line": 1212, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1217, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/OneDrive/Desktop/Next-Level-Technology/Assingment/Assingment6/client/node_modules/@tanstack/query-core/src/queryCache.ts"],"sourcesContent":["import { hashQueryKeyByOptions, matchQuery, parseFilterArgs } from './utils'\nimport { Query } from './query'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport type { QueryFilters } from './utils'\nimport type { Action, QueryState } from './query'\nimport type { NotifyEvent, QueryKey, QueryOptions } from './types'\nimport type { QueryClient } from './queryClient'\nimport type { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (error: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSuccess?: (data: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSettled?: (\n    data: unknown | undefined,\n    error: unknown | null,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n}\n\ninterface QueryHashMap {\n  [hash: string]: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryAdded extends NotifyEvent {\n  type: 'added'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryRemoved extends NotifyEvent {\n  type: 'removed'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryUpdated extends NotifyEvent {\n  type: 'updated'\n  query: Query<any, any, any, any>\n  action: Action<any, any>\n}\n\ninterface NotifyEventQueryObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverResultsUpdated extends NotifyEvent {\n  type: 'observerResultsUpdated'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\nexport type QueryCacheNotifyEvent =\n  | NotifyEventQueryAdded\n  | NotifyEventQueryRemoved\n  | NotifyEventQueryUpdated\n  | NotifyEventQueryObserverAdded\n  | NotifyEventQueryObserverRemoved\n  | NotifyEventQueryObserverResultsUpdated\n  | NotifyEventQueryObserverOptionsUpdated\n\ntype QueryCacheListener = (event: QueryCacheNotifyEvent) => void\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  config: QueryCacheConfig\n\n  private queries: Query<any, any, any, any>[]\n  private queriesMap: QueryHashMap\n\n  constructor(config?: QueryCacheConfig) {\n    super()\n    this.config = config || {}\n    this.queries = []\n    this.queriesMap = {}\n  }\n\n  build<TQueryFnData, TError, TData, TQueryKey extends QueryKey>(\n    client: QueryClient,\n    options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    state?: QueryState<TData, TError>,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> {\n    const queryKey = options.queryKey!\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData, TQueryKey>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any, any, any>): void {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query\n      this.queries.push(query)\n      this.notify({\n        type: 'added',\n        query,\n      })\n    }\n  }\n\n  remove(query: Query<any, any, any, any>): void {\n    const queryInMap = this.queriesMap[query.queryHash]\n\n    if (queryInMap) {\n      query.destroy()\n\n      this.queries = this.queries.filter((x) => x !== query)\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash]\n      }\n\n      this.notify({ type: 'removed', query })\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryHash: string,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> | undefined {\n    return this.queriesMap[queryHash]\n  }\n\n  getAll(): Query[] {\n    return this.queries\n  }\n\n  find<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    arg1: QueryKey,\n    arg2?: QueryFilters,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const [filters] = parseFilterArgs(arg1, arg2)\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true\n    }\n\n    return this.queries.find((query) => matchQuery(filters, query))\n  }\n\n  findAll(queryKey?: QueryKey, filters?: QueryFilters): Query[]\n  findAll(filters?: QueryFilters): Query[]\n  findAll(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): Query[]\n  findAll(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): Query[] {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    return Object.keys(filters).length > 0\n      ? this.queries.filter((query) => matchQuery(filters, query))\n      : this.queries\n  }\n\n  notify(event: QueryCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({ listener }) => {\n        listener(event)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        query.onOnline()\n      })\n    })\n  }\n}\n"],"names":["QueryCache","Subscribable","constructor","config","queries","queriesMap","build","client","options","state","queryKey","queryHash","hashQueryKeyByOptions","query","get","Query","cache","logger","getLogger","defaultQueryOptions","defaultOptions","getQueryDefaults","add","push","notify","type","remove","queryInMap","destroy","filter","x","clear","notifyManager","batch","forEach","getAll","find","arg1","arg2","filters","parseFilterArgs","exact","matchQuery","findAll","Object","keys","length","event","listeners","listener","onFocus","onOnline"],"mappings":"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"}},
    {"offset": {"line": 1328, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1333, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/OneDrive/Desktop/Next-Level-Technology/Assingment/Assingment6/client/node_modules/@tanstack/query-core/src/mutation.ts"],"sourcesContent":["import { defaultLogger } from './logger'\nimport { notifyManager } from './notifyManager'\nimport { Removable } from './removable'\nimport { canFetch, createRetryer } from './retryer'\nimport type { MutationMeta, MutationOptions, MutationStatus } from './types'\nimport type { MutationCache } from './mutationCache'\nimport type { MutationObserver } from './mutationObserver'\nimport type { Logger } from './logger'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface MutationConfig<TData, TError, TVariables, TContext> {\n  mutationId: number\n  mutationCache: MutationCache\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  logger?: Logger\n  defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  state?: MutationState<TData, TError, TVariables, TContext>\n  meta?: MutationMeta\n}\n\nexport interface MutationState<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> {\n  context: TContext | undefined\n  data: TData | undefined\n  error: TError | null\n  failureCount: number\n  failureReason: TError | null\n  isPaused: boolean\n  status: MutationStatus\n  variables: TVariables | undefined\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError | null\n}\n\ninterface LoadingAction<TVariables, TContext> {\n  type: 'loading'\n  variables?: TVariables\n  context?: TContext\n}\n\ninterface SuccessAction<TData> {\n  type: 'success'\n  data: TData\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError, TVariables, TContext> {\n  type: 'setState'\n  state: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport type Action<TData, TError, TVariables, TContext> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | LoadingAction<TVariables, TContext>\n  | PauseAction\n  | SetStateAction<TData, TError, TVariables, TContext>\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Mutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> extends Removable {\n  state: MutationState<TData, TError, TVariables, TContext>\n  options!: MutationOptions<TData, TError, TVariables, TContext>\n  mutationId: number\n\n  private observers: MutationObserver<TData, TError, TVariables, TContext>[]\n  private defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  private mutationCache: MutationCache\n  private logger: Logger\n  private retryer?: Retryer<TData>\n\n  constructor(config: MutationConfig<TData, TError, TVariables, TContext>) {\n    super()\n\n    this.defaultOptions = config.defaultOptions\n    this.mutationId = config.mutationId\n    this.mutationCache = config.mutationCache\n    this.logger = config.logger || defaultLogger\n    this.observers = []\n    this.state = config.state || getDefaultState()\n\n    this.setOptions(config.options)\n    this.scheduleGc()\n  }\n\n  setOptions(\n    options?: MutationOptions<TData, TError, TVariables, TContext>,\n  ): void {\n    this.options = { ...this.defaultOptions, ...options }\n\n    this.updateCacheTime(this.options.cacheTime)\n  }\n\n  get meta(): MutationMeta | undefined {\n    return this.options.meta\n  }\n\n  setState(state: MutationState<TData, TError, TVariables, TContext>): void {\n    this.dispatch({ type: 'setState', state })\n  }\n\n  addObserver(observer: MutationObserver<any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the mutation from being garbage collected\n      this.clearGcTimeout()\n\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer,\n      })\n    }\n  }\n\n  removeObserver(observer: MutationObserver<any, any, any, any>): void {\n    this.observers = this.observers.filter((x) => x !== observer)\n\n    this.scheduleGc()\n\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer,\n    })\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc()\n      } else {\n        this.mutationCache.remove(this)\n      }\n    }\n  }\n\n  continue(): Promise<unknown> {\n    return this.retryer?.continue() ?? this.execute()\n  }\n\n  async execute(): Promise<TData> {\n    const executeMutation = () => {\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found')\n          }\n          return this.options.mutationFn(this.state.variables!)\n        },\n        onFail: (failureCount, error) => {\n          this.dispatch({ type: 'failed', failureCount, error })\n        },\n        onPause: () => {\n          this.dispatch({ type: 'pause' })\n        },\n        onContinue: () => {\n          this.dispatch({ type: 'continue' })\n        },\n        retry: this.options.retry ?? 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode,\n      })\n\n      return this.retryer.promise\n    }\n\n    const restored = this.state.status === 'loading'\n    try {\n      if (!restored) {\n        this.dispatch({ type: 'loading', variables: this.options.variables! })\n        // Notify cache callback\n        await this.mutationCache.config.onMutate?.(\n          this.state.variables,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n        const context = await this.options.onMutate?.(this.state.variables!)\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables,\n          })\n        }\n      }\n      const data = await executeMutation()\n\n      // Notify cache callback\n      await this.mutationCache.config.onSuccess?.(\n        data,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSuccess?.(\n        data,\n        this.state.variables!,\n        this.state.context!,\n      )\n\n      // Notify cache callback\n      await this.mutationCache.config.onSettled?.(\n        data,\n        null,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSettled?.(\n        data,\n        null,\n        this.state.variables!,\n        this.state.context,\n      )\n\n      this.dispatch({ type: 'success', data })\n      return data\n    } catch (error) {\n      try {\n        // Notify cache callback\n        await this.mutationCache.config.onError?.(\n          error,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error)\n        }\n\n        await this.options.onError?.(\n          error as TError,\n          this.state.variables!,\n          this.state.context,\n        )\n\n        // Notify cache callback\n        await this.mutationCache.config.onSettled?.(\n          undefined,\n          error,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        await this.options.onSettled?.(\n          undefined,\n          error as TError,\n          this.state.variables!,\n          this.state.context,\n        )\n        throw error\n      } finally {\n        this.dispatch({ type: 'error', error: error as TError })\n      }\n    }\n  }\n\n  private dispatch(action: Action<TData, TError, TVariables, TContext>): void {\n    const reducer = (\n      state: MutationState<TData, TError, TVariables, TContext>,\n    ): MutationState<TData, TError, TVariables, TContext> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            isPaused: true,\n          }\n        case 'continue':\n          return {\n            ...state,\n            isPaused: false,\n          }\n        case 'loading':\n          return {\n            ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables,\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false,\n          }\n        case 'error':\n          return {\n            ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error',\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onMutationUpdate(action)\n      })\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action,\n      })\n    })\n  }\n}\n\nexport function getDefaultState<\n  TData,\n  TError,\n  TVariables,\n  TContext,\n>(): MutationState<TData, TError, TVariables, TContext> {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n  }\n}\n"],"names":["Mutation","Removable","constructor","config","defaultOptions","mutationId","mutationCache","logger","defaultLogger","observers","state","getDefaultState","setOptions","options","scheduleGc","updateCacheTime","cacheTime","meta","setState","dispatch","type","addObserver","observer","includes","push","clearGcTimeout","notify","mutation","removeObserver","filter","x","optionalRemove","length","status","remove","continue","retryer","execute","executeMutation","createRetryer","fn","mutationFn","Promise","reject","variables","onFail","failureCount","error","onPause","onContinue","retry","retryDelay","networkMode","promise","restored","onMutate","context","data","onSuccess","onSettled","onError","undefined","action","reducer","failureReason","isPaused","canFetch","notifyManager","batch","forEach","onMutationUpdate"],"mappings":"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"}},
    {"offset": {"line": 1575, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1580, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/OneDrive/Desktop/Next-Level-Technology/Assingment/Assingment6/client/node_modules/@tanstack/query-core/src/mutationCache.ts"],"sourcesContent":["import { notifyManager } from './notifyManager'\nimport { Mutation } from './mutation'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\nimport type { MutationObserver } from './mutationObserver'\nimport type { MutationOptions, NotifyEvent } from './types'\nimport type { QueryClient } from './queryClient'\nimport type { Action, MutationState } from './mutation'\nimport type { MutationFilters } from './utils'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: unknown | undefined,\n    error: unknown | null,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded extends NotifyEvent {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved extends NotifyEvent {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated extends NotifyEvent {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\ntype MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  config: MutationCacheConfig\n\n  private mutations: Mutation<any, any, any, any>[]\n  private mutationId: number\n  private resuming: Promise<unknown> | undefined\n\n  constructor(config?: MutationCacheConfig) {\n    super()\n    this.config = config || {}\n    this.mutations = []\n    this.mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>,\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey\n        ? client.getMutationDefaults(options.mutationKey)\n        : undefined,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.mutations.push(mutation)\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    this.mutations = this.mutations.filter((x) => x !== mutation)\n    this.notify({ type: 'removed', mutation })\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.mutations.forEach((mutation) => {\n        this.remove(mutation)\n      })\n    })\n  }\n\n  getAll(): Mutation[] {\n    return this.mutations\n  }\n\n  find<TData = unknown, TError = unknown, TVariables = any, TContext = unknown>(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true\n    }\n\n    return this.mutations.find((mutation) => matchMutation(filters, mutation))\n  }\n\n  findAll(filters: MutationFilters): Mutation[] {\n    return this.mutations.filter((mutation) => matchMutation(filters, mutation))\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({ listener }) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    this.resuming = (this.resuming ?? Promise.resolve())\n      .then(() => {\n        const pausedMutations = this.mutations.filter((x) => x.state.isPaused)\n        return notifyManager.batch(() =>\n          pausedMutations.reduce(\n            (promise, mutation) =>\n              promise.then(() => mutation.continue().catch(noop)),\n            Promise.resolve() as Promise<unknown>,\n          ),\n        )\n      })\n      .then(() => {\n        this.resuming = undefined\n      })\n\n    return this.resuming\n  }\n}\n"],"names":["MutationCache","Subscribable","constructor","config","mutations","mutationId","build","client","options","state","mutation","Mutation","mutationCache","logger","getLogger","defaultMutationOptions","defaultOptions","mutationKey","getMutationDefaults","undefined","add","push","notify","type","remove","filter","x","clear","notifyManager","batch","forEach","getAll","find","filters","exact","matchMutation","findAll","event","listeners","listener","resumePausedMutations","resuming","Promise","resolve","then","pausedMutations","isPaused","reduce","promise","continue","catch","noop"],"mappings":";;;;;;;;;;;;AAiFA,QAAA;AAEO,MAAMA,sBAAsBC,yQAAAA,CAAAA,eAA5B;IAOLC,YAAYC,MAAD,CAA+B;QACxC,KAAA;QACA,IAAA,CAAKA,MAAL,GAAcA,UAAU,CAAA;QACxB,IAAKC,CAAAA,SAAL,GAAiB,EAAjB;QACA,IAAKC,CAAAA,UAAL,GAAkB;IACnB;IAEDC,MACEC,MADG,EAEHC,OAFG,EAGHC,KAHG,EAI4C;QAC/C,MAAMC,WAAW,IAAIC,qQAAAA,CAAAA,WAAJ,CAAa;YAC5BC,eAAe,IADa;YAE5BC,QAAQN,OAAOO,SAAP;YACRT,YAAY,EAAE,IAAA,CAAKA,UAHS;YAI5BG,SAASD,OAAOQ,sBAAP,CAA8BP;YACvCC;YACAO,gBAAgBR,QAAQS,WAAR,GACZV,OAAOW,mBAAP,CAA2BV,QAAQS,WAAnC,IACAE;QARwB;QAW9B,IAAKC,CAAAA,GAAL,CAASV;QAET,OAAOA;IACR;IAEDU,IAAIV,QAAD,EAA+C;QAChD,IAAA,CAAKN,SAAL,CAAeiB,IAAf,CAAoBX;QACpB,IAAA,CAAKY,MAAL,CAAY;YAAEC,MAAM;YAASb;;IAC9B;IAEDc,OAAOd,QAAD,EAA+C;QACnD,IAAA,CAAKN,SAAL,GAAiB,IAAKA,CAAAA,SAAL,CAAeqB,MAAf,CAAuBC,CAAAA,IAAMA,MAAMhB;QACpD,IAAA,CAAKY,MAAL,CAAY;YAAEC,MAAM;YAAWb;;IAChC;IAEDiB,QAAc;QACZC,0QAAAA,CAAAA,gBAAa,CAACC,KAAd,CAAoB;YAClB,IAAA,CAAKzB,SAAL,CAAe0B,OAAf,CAAwBpB,CAAAA;gBACtB,IAAKc,CAAAA,MAAL,CAAYd;;;IAGjB;IAEDqB,SAAqB;QACnB,OAAO,IAAA,CAAK3B,SAAZ;IACD;IAED4B,KACEC,OADE,EAEyD;QAC3D,IAAI,OAAOA,QAAQC,KAAf,KAAyB,aAAa;YACxCD,QAAQC,KAAR,GAAgB;QACjB;QAED,OAAO,IAAK9B,CAAAA,SAAL,CAAe4B,IAAf,CAAqBtB,CAAAA,WAAayB,CAAAA,GAAAA,kQAAAA,CAAAA,gBAAa,AAAbA,EAAcF,SAASvB;IACjE;IAED0B,QAAQH,OAAD,EAAuC;QAC5C,OAAO,IAAK7B,CAAAA,SAAL,CAAeqB,MAAf,CAAuBf,CAAAA,WAAayB,CAAAA,GAAAA,kQAAAA,CAAAA,gBAAa,AAAbA,EAAcF,SAASvB;IACnE;IAEDY,OAAOe,KAAD,EAAkC;QACtCT,0QAAAA,CAAAA,gBAAa,CAACC,KAAd,CAAoB;YAClB,IAAA,CAAKS,SAAL,CAAeR,OAAf,CAAuB,CAAC,EAAES,QAAAA,EAAH;gBACrBA,SAASF;;;IAGd;IAEDG,wBAA0C;QAAA,IAAA;QACxC,IAAA,CAAKC,QAAL,GAAgB,CAAC,CAAA,iBAAA,IAAA,CAAKA,QAAN,KAAA,OAAA,iBAAkBC,QAAQC,OAAR,EAAlB,EACbC,IADa,CACR;YACJ,MAAMC,kBAAkB,IAAKzC,CAAAA,SAAL,CAAeqB,MAAf,CAAuBC,CAAAA,IAAMA,EAAEjB,KAAF,CAAQqC,QAArC;YACxB,OAAOlB,0QAAAA,CAAAA,gBAAa,CAACC,KAAd,CAAoB,IACzBgB,gBAAgBE,MAAhB,CACE,CAACC,SAAStC,WACRsC,QAAQJ,IAAR,CAAa,IAAMlC,SAASuC,QAAT,GAAoBC,KAApB,CAA0BC,kQAAAA,CAAAA,OAA1B,IACrBT,QAAQC,OAAR;WAILC,IAXa,CAWR;YACJ,IAAKH,CAAAA,QAAL,GAAgBtB;QACjB;QAEH,OAAO,IAAA,CAAKsB,QAAZ;IACD;AAhGoE"}},
    {"offset": {"line": 1665, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1670, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/OneDrive/Desktop/Next-Level-Technology/Assingment/Assingment6/client/node_modules/@tanstack/query-core/src/infiniteQueryBehavior.ts"],"sourcesContent":["import type { QueryBehavior } from './query'\n\nimport type {\n  InfiniteData,\n  QueryFunctionContext,\n  QueryOptions,\n  RefetchQueryFilters,\n} from './types'\n\nexport function infiniteQueryBehavior<\n  TQueryFnData,\n  TError,\n  TData,\n>(): QueryBehavior<TQueryFnData, TError, InfiniteData<TData>> {\n  return {\n    onFetch: (context) => {\n      context.fetchFn = () => {\n        const refetchPage: RefetchQueryFilters['refetchPage'] | undefined =\n          context.fetchOptions?.meta?.refetchPage\n        const fetchMore = context.fetchOptions?.meta?.fetchMore\n        const pageParam = fetchMore?.pageParam\n        const isFetchingNextPage = fetchMore?.direction === 'forward'\n        const isFetchingPreviousPage = fetchMore?.direction === 'backward'\n        const oldPages = context.state.data?.pages || []\n        const oldPageParams = context.state.data?.pageParams || []\n        let newPageParams = oldPageParams\n        let cancelled = false\n\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal?.aborted) {\n                cancelled = true\n              } else {\n                context.signal?.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        // Get query function\n        const queryFn =\n          context.options.queryFn ||\n          (() =>\n            Promise.reject(\n              `Missing queryFn for queryKey '${context.options.queryHash}'`,\n            ))\n\n        const buildNewPages = (\n          pages: unknown[],\n          param: unknown,\n          page: unknown,\n          previous?: boolean,\n        ) => {\n          newPageParams = previous\n            ? [param, ...newPageParams]\n            : [...newPageParams, param]\n          return previous ? [page, ...pages] : [...pages, page]\n        }\n\n        // Create function to fetch a page\n        const fetchPage = (\n          pages: unknown[],\n          manual?: boolean,\n          param?: unknown,\n          previous?: boolean,\n        ): Promise<unknown[]> => {\n          if (cancelled) {\n            return Promise.reject('Cancelled')\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages)\n          }\n\n          const queryFnContext: QueryFunctionContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.options.meta,\n          }\n\n          addSignalProperty(queryFnContext)\n\n          const queryFnResult = queryFn(queryFnContext)\n\n          const promise = Promise.resolve(queryFnResult).then((page) =>\n            buildNewPages(pages, param, page, previous),\n          )\n\n          return promise\n        }\n\n        let promise: Promise<unknown[]>\n\n        // Fetch first page?\n        if (!oldPages.length) {\n          promise = fetchPage([])\n        }\n\n        // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getNextPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param)\n        }\n\n        // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getPreviousPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param, true)\n        }\n\n        // Refetch pages\n        else {\n          newPageParams = []\n\n          const manual = typeof context.options.getNextPageParam === 'undefined'\n\n          const shouldFetchFirstPage =\n            refetchPage && oldPages[0]\n              ? refetchPage(oldPages[0], 0, oldPages)\n              : true\n\n          // Fetch first page\n          promise = shouldFetchFirstPage\n            ? fetchPage([], manual, oldPageParams[0])\n            : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]))\n\n          // Fetch remaining pages\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then((pages) => {\n              const shouldFetchNextPage =\n                refetchPage && oldPages[i]\n                  ? refetchPage(oldPages[i], i, oldPages)\n                  : true\n\n              if (shouldFetchNextPage) {\n                const param = manual\n                  ? oldPageParams[i]\n                  : getNextPageParam(context.options, pages)\n                return fetchPage(pages, manual, param)\n              }\n              return Promise.resolve(\n                buildNewPages(pages, oldPageParams[i], oldPages[i]),\n              )\n            })\n          }\n        }\n\n        const finalPromise = promise.then((pages) => ({\n          pages,\n          pageParams: newPageParams,\n        }))\n\n        return finalPromise\n      }\n    },\n  }\n}\n\nexport function getNextPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[],\n): unknown | undefined {\n  return options.getNextPageParam?.(pages[pages.length - 1], pages)\n}\n\nexport function getPreviousPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[],\n): unknown | undefined {\n  return options.getPreviousPageParam?.(pages[0], pages)\n}\n\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasNextPage(\n  options: QueryOptions<any, any, any, any>,\n  pages?: unknown,\n): boolean | undefined {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages)\n    return (\n      typeof nextPageParam !== 'undefined' &&\n      nextPageParam !== null &&\n      nextPageParam !== false\n    )\n  }\n  return\n}\n\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasPreviousPage(\n  options: QueryOptions<any, any, any, any>,\n  pages?: unknown,\n): boolean | undefined {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages)\n    return (\n      typeof previousPageParam !== 'undefined' &&\n      previousPageParam !== null &&\n      previousPageParam !== false\n    )\n  }\n  return\n}\n"],"names":["infiniteQueryBehavior","onFetch","context","fetchFn","refetchPage","fetchOptions","meta","fetchMore","pageParam","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","state","data","pages","oldPageParams","pageParams","newPageParams","cancelled","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","aborted","addEventListener","queryFn","options","Promise","reject","queryHash","buildNewPages","param","page","previous","fetchPage","manual","length","resolve","queryFnContext","queryKey","queryFnResult","promise","then","getNextPageParam","getPreviousPageParam","shouldFetchFirstPage","i","shouldFetchNextPage","finalPromise","hasNextPage","Array","isArray","nextPageParam","hasPreviousPage","previousPageParam"],"mappings":"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"}},
    {"offset": {"line": 1806, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1811, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/OneDrive/Desktop/Next-Level-Technology/Assingment/Assingment6/client/node_modules/@tanstack/query-core/src/queryClient.ts"],"sourcesContent":["import {\n  functionalUpdate,\n  hashQueryKey,\n  hashQueryKeyByOptions,\n  noop,\n  parseFilterArgs,\n  parseQueryArgs,\n  partialMatchKey,\n} from './utils'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport { defaultLogger } from './logger'\nimport type { CancelOptions, DefaultedQueryObserverOptions } from './types'\nimport type { Logger } from './logger'\nimport type { QueryState } from './query'\nimport type {\n  DefaultOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  QueryClientConfig,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  ResetQueryFilters,\n  SetDataOptions,\n  WithRequired,\n} from './types'\nimport type { MutationFilters, QueryFilters, Updater } from './utils'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: QueryOptions<any, any, any>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  private queryCache: QueryCache\n  private mutationCache: MutationCache\n  private logger: Logger\n  private defaultOptions: DefaultOptions\n  private queryDefaults: QueryDefaults[]\n  private mutationDefaults: MutationDefaults[]\n  private mountCount: number\n  private unsubscribeFocus?: () => void\n  private unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.queryCache = config.queryCache || new QueryCache()\n    this.mutationCache = config.mutationCache || new MutationCache()\n    this.logger = config.logger || defaultLogger\n    this.defaultOptions = config.defaultOptions || {}\n    this.queryDefaults = []\n    this.mutationDefaults = []\n    this.mountCount = 0\n\n    if (process.env.NODE_ENV !== 'production' && config.logger) {\n      this.logger.error(\n        `Passing a custom logger has been deprecated and will be removed in the next major version.`,\n      )\n    }\n  }\n\n  mount(): void {\n    this.mountCount++\n    if (this.mountCount !== 1) return\n\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations()\n        this.queryCache.onFocus()\n      }\n    })\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations()\n        this.queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.mountCount--\n    if (this.mountCount !== 0) return\n\n    this.unsubscribeFocus?.()\n    this.unsubscribeFocus = undefined\n\n    this.unsubscribeOnline?.()\n    this.unsubscribeOnline = undefined\n  }\n\n  isFetching(filters?: QueryFilters): number\n  isFetching(queryKey?: QueryKey, filters?: QueryFilters): number\n  isFetching(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): number {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    filters.fetchStatus = 'fetching'\n    return this.queryCache.findAll(filters).length\n  }\n\n  isMutating(filters?: MutationFilters): number {\n    return this.mutationCache.findAll({ ...filters, fetching: true }).length\n  }\n\n  getQueryData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n    filters?: QueryFilters,\n  ): TQueryFnData | undefined {\n    return this.queryCache.find<TQueryFnData>(queryKey, filters)?.state.data\n  }\n\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: WithRequired<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: Omit<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: Omit<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey' | 'queryFn'\n    >,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | WithRequired<\n          FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n          'queryKey'\n        >,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const cachedData = this.getQueryData<TData>(parsedOptions.queryKey!)\n\n    return cachedData\n      ? Promise.resolve(cachedData)\n      : this.fetchQuery(parsedOptions)\n  }\n\n  getQueriesData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n  ): [QueryKey, TQueryFnData | undefined][]\n  getQueriesData<TQueryFnData = unknown>(\n    filters: QueryFilters,\n  ): [QueryKey, TQueryFnData | undefined][]\n  getQueriesData<TQueryFnData = unknown>(\n    queryKeyOrFilters: QueryKey | QueryFilters,\n  ): [QueryKey, TQueryFnData | undefined][] {\n    return this.getQueryCache()\n      .findAll(queryKeyOrFilters)\n      .map(({ queryKey, state }) => {\n        const data = state.data as TQueryFnData | undefined\n        return [queryKey, data]\n      })\n  }\n\n  setQueryData<TQueryFnData>(\n    queryKey: QueryKey,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): TQueryFnData | undefined {\n    const query = this.queryCache.find<TQueryFnData>(queryKey)\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (typeof data === 'undefined') {\n      return undefined\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n    return this.queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<TQueryFnData>(\n    queryKey: QueryKey,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][]\n\n  setQueriesData<TQueryFnData>(\n    filters: QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][]\n\n  setQueriesData<TQueryFnData>(\n    queryKeyOrFilters: QueryKey | QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][] {\n    return notifyManager.batch(() =>\n      this.getQueryCache()\n        .findAll(queryKeyOrFilters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<TQueryFnData = unknown, TError = undefined>(\n    queryKey: QueryKey,\n    filters?: QueryFilters,\n  ): QueryState<TQueryFnData, TError> | undefined {\n    return this.queryCache.find<TQueryFnData, TError>(queryKey, filters)?.state\n  }\n\n  removeQueries(filters?: QueryFilters): void\n  removeQueries(queryKey?: QueryKey, filters?: QueryFilters): void\n  removeQueries(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): void {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    const queryCache = this.queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries<TPageData = unknown>(\n    filters?: ResetQueryFilters<TPageData>,\n    options?: ResetOptions,\n  ): Promise<void>\n  resetQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: ResetQueryFilters<TPageData>,\n    options?: ResetOptions,\n  ): Promise<void>\n  resetQueries(\n    arg1?: QueryKey | ResetQueryFilters,\n    arg2?: ResetQueryFilters | ResetOptions,\n    arg3?: ResetOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n    const queryCache = this.queryCache\n\n    const refetchFilters: RefetchQueryFilters = {\n      type: 'active',\n      ...filters,\n    }\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  cancelQueries(filters?: QueryFilters, options?: CancelOptions): Promise<void>\n  cancelQueries(\n    queryKey?: QueryKey,\n    filters?: QueryFilters,\n    options?: CancelOptions,\n  ): Promise<void>\n  cancelQueries(\n    arg1?: QueryKey | QueryFilters,\n    arg2?: QueryFilters | CancelOptions,\n    arg3?: CancelOptions,\n  ): Promise<void> {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3)\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true\n    }\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(cancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries<TPageData = unknown>(\n    filters?: InvalidateQueryFilters<TPageData>,\n    options?: InvalidateOptions,\n  ): Promise<void>\n  invalidateQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: InvalidateQueryFilters<TPageData>,\n    options?: InvalidateOptions,\n  ): Promise<void>\n  invalidateQueries(\n    arg1?: QueryKey | InvalidateQueryFilters,\n    arg2?: InvalidateQueryFilters | InvalidateOptions,\n    arg3?: InvalidateOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    return notifyManager.batch(() => {\n      this.queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      const refetchFilters: RefetchQueryFilters = {\n        ...filters,\n        type: filters.refetchType ?? filters.type ?? 'active',\n      }\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  refetchQueries<TPageData = unknown>(\n    filters?: RefetchQueryFilters<TPageData>,\n    options?: RefetchOptions,\n  ): Promise<void>\n  refetchQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: RefetchQueryFilters<TPageData>,\n    options?: RefetchOptions,\n  ): Promise<void>\n  refetchQueries(\n    arg1?: QueryKey | RefetchQueryFilters,\n    arg2?: RefetchQueryFilters | RefetchOptions,\n    arg3?: RefetchOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled())\n        .map((query) =>\n          query.fetch(undefined, {\n            ...options,\n            cancelRefetch: options?.cancelRefetch ?? true,\n            meta: { refetchPage: filters.refetchPage },\n          }),\n        ),\n    )\n\n    let promise = Promise.all(promises).then(noop)\n\n    if (!options?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(defaultedOptions.staleTime)\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    parsedOptions.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData\n    >()\n    return this.fetchQuery(parsedOptions)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    return this.mutationCache.resumePausedMutations()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.mutationCache\n  }\n\n  getLogger(): Logger {\n    return this.logger\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.defaultOptions = options\n  }\n\n  setQueryDefaults(\n    queryKey: QueryKey,\n    options: QueryObserverOptions<unknown, any, any, any>,\n  ): void {\n    const result = this.queryDefaults.find(\n      (x) => hashQueryKey(queryKey) === hashQueryKey(x.queryKey),\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.queryDefaults.push({ queryKey, defaultOptions: options })\n    }\n  }\n\n  getQueryDefaults(\n    queryKey?: QueryKey,\n  ): QueryObserverOptions<any, any, any, any, any> | undefined {\n    if (!queryKey) {\n      return undefined\n    }\n\n    // Get the first matching defaults\n    const firstMatchingDefaults = this.queryDefaults.find((x) =>\n      partialMatchKey(queryKey, x.queryKey),\n    )\n\n    // Additional checks and error in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter((x) =>\n        partialMatchKey(queryKey, x.queryKey),\n      )\n      // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\n          `[QueryClient] Several query defaults match with key '${JSON.stringify(\n            queryKey,\n          )}'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.`,\n        )\n      }\n    }\n\n    return firstMatchingDefaults?.defaultOptions\n  }\n\n  setMutationDefaults(\n    mutationKey: MutationKey,\n    options: MutationObserverOptions<any, any, any, any>,\n  ): void {\n    const result = this.mutationDefaults.find(\n      (x) => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey),\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.mutationDefaults.push({ mutationKey, defaultOptions: options })\n    }\n  }\n\n  getMutationDefaults(\n    mutationKey?: MutationKey,\n  ): MutationObserverOptions<any, any, any, any> | undefined {\n    if (!mutationKey) {\n      return undefined\n    }\n\n    // Get the first matching defaults\n    const firstMatchingDefaults = this.mutationDefaults.find((x) =>\n      partialMatchKey(mutationKey, x.mutationKey),\n    )\n\n    // Additional checks and error in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter((x) =>\n        partialMatchKey(mutationKey, x.mutationKey),\n      )\n      // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\n          `[QueryClient] Several mutation defaults match with key '${JSON.stringify(\n            mutationKey,\n          )}'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.`,\n        )\n      }\n    }\n\n    return firstMatchingDefaults?.defaultOptions\n  }\n\n  defaultQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey extends QueryKey,\n  >(\n    options?:\n      | QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options?._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options?.queryKey),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options?.mutationKey),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.queryCache.clear()\n    this.mutationCache.clear()\n  }\n}\n"],"names":["QueryClient","constructor","config","queryCache","QueryCache","mutationCache","MutationCache","logger","defaultLogger","defaultOptions","queryDefaults","mutationDefaults","mountCount","process","error","mount","unsubscribeFocus","focusManager","subscribe","isFocused","resumePausedMutations","onFocus","unsubscribeOnline","onlineManager","isOnline","onOnline","unmount","undefined","isFetching","arg1","arg2","filters","parseFilterArgs","fetchStatus","findAll","length","isMutating","fetching","getQueryData","queryKey","find","state","data","ensureQueryData","arg3","parsedOptions","parseQueryArgs","cachedData","Promise","resolve","fetchQuery","getQueriesData","queryKeyOrFilters","getQueryCache","map","setQueryData","updater","options","query","prevData","functionalUpdate","defaultedOptions","defaultQueryOptions","build","setData","manual","setQueriesData","notifyManager","batch","getQueryState","removeQueries","forEach","remove","resetQueries","refetchFilters","type","reset","refetchQueries","cancelQueries","cancelOptions","revert","promises","cancel","all","then","noop","catch","invalidateQueries","invalidate","refetchType","filter","isDisabled","fetch","cancelRefetch","meta","refetchPage","promise","throwOnError","retry","isStaleByTime","staleTime","prefetchQuery","fetchInfiniteQuery","behavior","infiniteQueryBehavior","prefetchInfiniteQuery","getMutationCache","getLogger","getDefaultOptions","setDefaultOptions","setQueryDefaults","result","x","hashQueryKey","push","getQueryDefaults","firstMatchingDefaults","partialMatchKey","matchingDefaults","JSON","stringify","setMutationDefaults","mutationKey","getMutationDefaults","_defaulted","queries","queryHash","hashQueryKeyByOptions","refetchOnReconnect","networkMode","useErrorBoundary","suspense","defaultMutationOptions","mutations","clear"],"mappings":"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"}},
    {"offset": {"line": 2116, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}